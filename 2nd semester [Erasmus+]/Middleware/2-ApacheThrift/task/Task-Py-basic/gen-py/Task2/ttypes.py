#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class FetchStatus(object):
    PENDING = 1
    ITEM = 2
    ENDED = 3

    _VALUES_TO_NAMES = {
        1: "PENDING",
        2: "ITEM",
        3: "ENDED",
    }

    _NAMES_TO_VALUES = {
        "PENDING": 1,
        "ITEM": 2,
        "ENDED": 3,
    }


class InvalidKeyException(TException):
    """
    Attributes:
     - invalidKey
     - expectedKey

    """


    def __init__(self, invalidKey=None, expectedKey=None,):
        super(InvalidKeyException, self).__setattr__('invalidKey', invalidKey)
        super(InvalidKeyException, self).__setattr__('expectedKey', expectedKey)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.invalidKey, self.expectedKey, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        invalidKey = None
        expectedKey = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    invalidKey = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    expectedKey = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            invalidKey=invalidKey,
            expectedKey=expectedKey,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidKeyException')
        if self.invalidKey is not None:
            oprot.writeFieldBegin('invalidKey', TType.I32, 1)
            oprot.writeI32(self.invalidKey)
            oprot.writeFieldEnd()
        if self.expectedKey is not None:
            oprot.writeFieldBegin('expectedKey', TType.I32, 2)
            oprot.writeI32(self.expectedKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ProtocolException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(ProtocolException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ProtocolException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemA(object):
    """
    Attributes:
     - fieldX
     - fieldY
     - fieldZ

    """


    def __init__(self, fieldX=None, fieldY=None, fieldZ=None,):
        self.fieldX = fieldX
        self.fieldY = fieldY
        self.fieldZ = fieldZ

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fieldX = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.fieldY = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI16()
                        self.fieldY.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fieldZ = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemA')
        if self.fieldX is not None:
            oprot.writeFieldBegin('fieldX', TType.STRING, 1)
            oprot.writeString(self.fieldX.encode('utf-8') if sys.version_info[0] == 2 else self.fieldX)
            oprot.writeFieldEnd()
        if self.fieldY is not None:
            oprot.writeFieldBegin('fieldY', TType.LIST, 2)
            oprot.writeListBegin(TType.I16, len(self.fieldY))
            for iter6 in self.fieldY:
                oprot.writeI16(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fieldZ is not None:
            oprot.writeFieldBegin('fieldZ', TType.I32, 3)
            oprot.writeI32(self.fieldZ)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fieldX is None:
            raise TProtocolException(message='Required field fieldX is unset!')
        if self.fieldY is None:
            raise TProtocolException(message='Required field fieldY is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FetchResult(object):
    """
    Attributes:
     - status
     - item

    """


    def __init__(self, status=None, item=None,):
        self.status = status
        self.item = item

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.item = ItemA()
                    self.item.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FetchResult')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 1)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.item is not None:
            oprot.writeFieldBegin('item', TType.STRUCT, 2)
            self.item.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(InvalidKeyException)
InvalidKeyException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'invalidKey', None, None, ),  # 1
    (2, TType.I32, 'expectedKey', None, None, ),  # 2
)
all_structs.append(ProtocolException)
ProtocolException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(ItemA)
ItemA.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fieldX', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'fieldY', (TType.I16, None, False), None, ),  # 2
    (3, TType.I32, 'fieldZ', None, None, ),  # 3
)
all_structs.append(FetchResult)
FetchResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'status', None, None, ),  # 1
    (2, TType.STRUCT, 'item', [ItemA, None], None, ),  # 2
)
fix_spec(all_structs)
del all_structs
