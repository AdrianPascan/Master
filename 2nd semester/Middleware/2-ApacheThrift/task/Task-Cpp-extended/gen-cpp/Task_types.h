/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Task_TYPES_H
#define Task_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace Task2 {

struct FetchStatus {
  enum type {
    PENDING = 1,
    ITEM = 2,
    ENDED = 3
  };
};

extern const std::map<int, const char*> _FetchStatus_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const FetchStatus::type& val);

std::string to_string(const FetchStatus::type& val);

typedef std::map<std::string, std::set<std::string> >  Summary;

class InvalidKeyException;

class ProtocolException;

class ItemA;

class ItemB;

class ItemC;

class Item;

class FetchResult;

class FetchMultipleResult;

typedef struct _InvalidKeyException__isset {
  _InvalidKeyException__isset() : invalidKey(false), expectedKey(false) {}
  bool invalidKey :1;
  bool expectedKey :1;
} _InvalidKeyException__isset;

class InvalidKeyException : public ::apache::thrift::TException {
 public:

  InvalidKeyException(const InvalidKeyException&);
  InvalidKeyException& operator=(const InvalidKeyException&);
  InvalidKeyException() : invalidKey(0), expectedKey(0) {
  }

  virtual ~InvalidKeyException() noexcept;
  int32_t invalidKey;
  int32_t expectedKey;

  _InvalidKeyException__isset __isset;

  void __set_invalidKey(const int32_t val);

  void __set_expectedKey(const int32_t val);

  bool operator == (const InvalidKeyException & rhs) const
  {
    if (!(invalidKey == rhs.invalidKey))
      return false;
    if (!(expectedKey == rhs.expectedKey))
      return false;
    return true;
  }
  bool operator != (const InvalidKeyException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidKeyException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept;
};

void swap(InvalidKeyException &a, InvalidKeyException &b);

std::ostream& operator<<(std::ostream& out, const InvalidKeyException& obj);

typedef struct _ProtocolException__isset {
  _ProtocolException__isset() : message(false) {}
  bool message :1;
} _ProtocolException__isset;

class ProtocolException : public ::apache::thrift::TException {
 public:

  ProtocolException(const ProtocolException&);
  ProtocolException& operator=(const ProtocolException&);
  ProtocolException() : message() {
  }

  virtual ~ProtocolException() noexcept;
  std::string message;

  _ProtocolException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const ProtocolException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const ProtocolException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProtocolException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept;
};

void swap(ProtocolException &a, ProtocolException &b);

std::ostream& operator<<(std::ostream& out, const ProtocolException& obj);

typedef struct _ItemA__isset {
  _ItemA__isset() : fieldZ(false) {}
  bool fieldZ :1;
} _ItemA__isset;

class ItemA : public virtual ::apache::thrift::TBase {
 public:

  ItemA(const ItemA&);
  ItemA& operator=(const ItemA&);
  ItemA() : fieldX(), fieldZ(0) {
  }

  virtual ~ItemA() noexcept;
  std::string fieldX;
  std::vector<int16_t>  fieldY;
  int32_t fieldZ;

  _ItemA__isset __isset;

  void __set_fieldX(const std::string& val);

  void __set_fieldY(const std::vector<int16_t> & val);

  void __set_fieldZ(const int32_t val);

  bool operator == (const ItemA & rhs) const
  {
    if (!(fieldX == rhs.fieldX))
      return false;
    if (!(fieldY == rhs.fieldY))
      return false;
    if (__isset.fieldZ != rhs.__isset.fieldZ)
      return false;
    else if (__isset.fieldZ && !(fieldZ == rhs.fieldZ))
      return false;
    return true;
  }
  bool operator != (const ItemA &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemA & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemA &a, ItemA &b);

std::ostream& operator<<(std::ostream& out, const ItemA& obj);

typedef struct _ItemB__isset {
  _ItemB__isset() : fieldY(false) {}
  bool fieldY :1;
} _ItemB__isset;

class ItemB : public virtual ::apache::thrift::TBase {
 public:

  ItemB(const ItemB&);
  ItemB& operator=(const ItemB&);
  ItemB() : fieldX(0) {
  }

  virtual ~ItemB() noexcept;
  int16_t fieldX;
  std::vector<std::string>  fieldY;
  std::set<std::string>  fieldZ;

  _ItemB__isset __isset;

  void __set_fieldX(const int16_t val);

  void __set_fieldY(const std::vector<std::string> & val);

  void __set_fieldZ(const std::set<std::string> & val);

  bool operator == (const ItemB & rhs) const
  {
    if (!(fieldX == rhs.fieldX))
      return false;
    if (__isset.fieldY != rhs.__isset.fieldY)
      return false;
    else if (__isset.fieldY && !(fieldY == rhs.fieldY))
      return false;
    if (!(fieldZ == rhs.fieldZ))
      return false;
    return true;
  }
  bool operator != (const ItemB &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemB & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemB &a, ItemB &b);

std::ostream& operator<<(std::ostream& out, const ItemB& obj);


class ItemC : public virtual ::apache::thrift::TBase {
 public:

  ItemC(const ItemC&);
  ItemC& operator=(const ItemC&);
  ItemC() : fieldX(0) {
  }

  virtual ~ItemC() noexcept;
  bool fieldX;

  void __set_fieldX(const bool val);

  bool operator == (const ItemC & rhs) const
  {
    if (!(fieldX == rhs.fieldX))
      return false;
    return true;
  }
  bool operator != (const ItemC &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemC & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemC &a, ItemC &b);

std::ostream& operator<<(std::ostream& out, const ItemC& obj);

typedef struct _Item__isset {
  _Item__isset() : itemA(false), itemB(false), itemC(false) {}
  bool itemA :1;
  bool itemB :1;
  bool itemC :1;
} _Item__isset;

class Item : public virtual ::apache::thrift::TBase {
 public:

  Item(const Item&);
  Item& operator=(const Item&);
  Item() : type() {
  }

  virtual ~Item() noexcept;
  ItemA itemA;
  ItemB itemB;
  ItemC itemC;
  std::string type;

  _Item__isset __isset;

  void __set_itemA(const ItemA& val);

  void __set_itemB(const ItemB& val);

  void __set_itemC(const ItemC& val);

  void __set_type(const std::string& val);

  bool operator == (const Item & rhs) const
  {
    if (__isset.itemA != rhs.__isset.itemA)
      return false;
    else if (__isset.itemA && !(itemA == rhs.itemA))
      return false;
    if (__isset.itemB != rhs.__isset.itemB)
      return false;
    else if (__isset.itemB && !(itemB == rhs.itemB))
      return false;
    if (__isset.itemC != rhs.__isset.itemC)
      return false;
    else if (__isset.itemC && !(itemC == rhs.itemC))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const Item &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Item & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Item &a, Item &b);

std::ostream& operator<<(std::ostream& out, const Item& obj);

typedef struct _FetchResult__isset {
  _FetchResult__isset() : status(false), item(false) {}
  bool status :1;
  bool item :1;
} _FetchResult__isset;

class FetchResult : public virtual ::apache::thrift::TBase {
 public:

  FetchResult(const FetchResult&);
  FetchResult& operator=(const FetchResult&);
  FetchResult() : status((FetchStatus::type)0) {
  }

  virtual ~FetchResult() noexcept;
  /**
   * 
   * @see FetchStatus
   */
  FetchStatus::type status;
  ItemA item;

  _FetchResult__isset __isset;

  void __set_status(const FetchStatus::type val);

  void __set_item(const ItemA& val);

  bool operator == (const FetchResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(item == rhs.item))
      return false;
    return true;
  }
  bool operator != (const FetchResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FetchResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FetchResult &a, FetchResult &b);

std::ostream& operator<<(std::ostream& out, const FetchResult& obj);

typedef struct _FetchMultipleResult__isset {
  _FetchMultipleResult__isset() : status(false), items(false) {}
  bool status :1;
  bool items :1;
} _FetchMultipleResult__isset;

class FetchMultipleResult : public virtual ::apache::thrift::TBase {
 public:

  FetchMultipleResult(const FetchMultipleResult&);
  FetchMultipleResult& operator=(const FetchMultipleResult&);
  FetchMultipleResult() : status((FetchStatus::type)0) {
  }

  virtual ~FetchMultipleResult() noexcept;
  /**
   * 
   * @see FetchStatus
   */
  FetchStatus::type status;
  std::vector<Item>  items;

  _FetchMultipleResult__isset __isset;

  void __set_status(const FetchStatus::type val);

  void __set_items(const std::vector<Item> & val);

  bool operator == (const FetchMultipleResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(items == rhs.items))
      return false;
    return true;
  }
  bool operator != (const FetchMultipleResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FetchMultipleResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FetchMultipleResult &a, FetchMultipleResult &b);

std::ostream& operator<<(std::ostream& out, const FetchMultipleResult& obj);

} // namespace

#endif
